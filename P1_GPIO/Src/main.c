/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"


/*#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
*/
__IO uint32_t Tick; //__IO volatile
uint32_t TimerLD2;

void ClockConfig();
void ConfigLD1 ();
void ConfigLD2 ();
void ConfigButton();
void Delay(uint32_t delay_ms);
uint32_t GetSystemTick(void);

int main(void)
{
	ClockConfig();
	SysTick_Config(16000000/1000);
	ConfigLD1();
	ConfigLD2();
	ConfigButton();
	TimerLD2=GetSystemTick();
	/* Loop forever */
	while(1){
		if((GPIOA->IDR&(GPIO_IDR_ID6))==0){ // check button state
			GPIOA->BSRR |= GPIO_BSRR_BS5; //LED ON
		}
		else{
			GPIOA->BSRR |= GPIO_BSRR_BR5; //LD OFF
		}
		if(GetSystemTick()-TimerLD2>500){
			TimerLD2=GetSystemTick(); //Blink without delay
			GPIOA->ODR^=GPIO_ODR_OD7; //LD TOGGLE (XOR)
		}

		/*
		GPIOA->BSRR |= GPIO_BSRR_BS5; //LED ON
		Delay(1000);
		GPIOA->BSRR |= GPIO_BSRR_BR5; //LD OFF
		Delay(1000);*/
	}
}
void ClockConfig(){
	RCC->CR |= RCC_CR_MSION; // Active clock source
	while(!(RCC->CR&RCC_CR_MSIRDY)); //wait for clock source ready
	RCC->CR &= ~RCC_CR_MSIRANGE; //Clear range
	RCC->CR |= RCC_CR_MSIRANGE_8;// set range
	RCC->CR |= RCC_CR_MSIRGSEL;// enable to read from range
	RCC->CFGR &= ~RCC_CFGR_SW; // clear clock source
	RCC->CFGR |= RCC_CFGR_SW_MSI;// set clock source
	while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI);//wait until MSI is set as clock source


}
void ConfigLD1(){
	RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN;//Active port
	GPIOA->MODER |= GPIO_MODER_MODE5_0;//set output
	GPIOA->MODER &= ~(GPIO_MODER_MODE5_1);
	GPIOA->OTYPER &= ~(GPIO_OTYPER_OT5);// push pull
	GPIOA->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED5);// speed react
	GPIOA->PUPDR &= ~(GPIO_PUPDR_PUPD5);//no pull up, pull down

}
void ConfigLD2(){
	RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN;//Active port
	GPIOA->MODER |= GPIO_MODER_MODE7_0;//set output
	GPIOA->MODER &= ~(GPIO_MODER_MODE7_1);
	GPIOA->OTYPER &= ~(GPIO_OTYPER_OT7);// push pull
	GPIOA->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED7);// speed react
	GPIOA->PUPDR &= ~(GPIO_PUPDR_PUPD7);//no pull up, pull down

}
void ConfigButton(){
	RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN;
	GPIOA->MODER &= ~(GPIO_MODER_MODE6);//set input
	GPIOA->PUPDR &= ~(GPIO_PUPDR_PUPD6_1);// pull up
	GPIOA->PUPDR |= GPIO_PUPDR_PUPD6_0;
}
void SysTick_Handler(void){
	Tick++;
}

void Delay(uint32_t delay_ms){
	uint32_t StartTime=Tick;
	while(Tick<(StartTime+delay_ms));
}
uint32_t GetSystemTick(void){
	return Tick;
}
