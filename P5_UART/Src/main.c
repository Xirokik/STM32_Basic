/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"
#include "gpio_conf.h"


__IO uint32_t Tick;


void UART2_Config(void);
void UART2_SendChar(char c);
void UART2_SendStr(char *str);
uint8_t UART2_RecChar(char *ch);
uint32_t GetSystemTick(void);
void Delay(uint32_t delay_ms);

/*#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
*/
char rxbuffer[20];
uint8_t rxpos=0;
char tab1[20];
uint8_t CompareReady=0;

int main(void)
{
	SysTick_Config(4000000/1000);
	UART2_Config();
	ConfigOutput();
	ConfigOutput2();
	UART2_SendStr("Hello World\n\r");
	char ReceiveChar;
	while(1){
		uint8_t ReceiveStatus = UART2_RecChar(&ReceiveChar);
		//compare to single char
		if(ReceiveStatus == 0){
					// char received
			if(ReceiveChar == '1'){
				GPIOA->BSRR = GPIO_BSRR_BS5;
				}
			else if(ReceiveChar == '0'){
				GPIOA->BSRR = GPIO_BSRR_BR5;
				}
		}
		else{
			// char NOT received}
		}
			//compare string
		if(CompareReady){
		if(strcmp(tab1,"LDON")==0){
			GPIOA->BSRR = GPIO_BSRR_BS7;
			}
		else if(strcmp(tab1,"LDOFF")==0){
			GPIOA->BSRR = GPIO_BSRR_BR7;
			}
		CompareReady=0;
		}

	}
}

void UART2_Config(){
	RCC-> AHB2ENR |= RCC_AHB2ENR_GPIOAEN;
	//PA2 TX
	GPIOA-> MODER &= ~(GPIO_MODER_MODE2_0);
	GPIOA-> AFR[0] |= GPIO_AFRL_AFSEL2_0 | GPIO_AFRL_AFSEL2_1 | GPIO_AFRL_AFSEL2_2; //alternate function

	//PA3 RX
	GPIOA-> MODER &= ~(GPIO_MODER_MODE3_0);
	GPIOA-> AFR[0] |= GPIO_AFRL_AFSEL3_0 | GPIO_AFRL_AFSEL3_1 | GPIO_AFRL_AFSEL3_2; //alternate function
	GPIOA-> OTYPER |= GPIO_OTYPER_OT3;


	RCC->APB1ENR1 |= RCC_APB1ENR1_USART2EN; //Active UART
	USART2->CR2&=~(USART_CR2_STOP);//1 stop bit
	USART2->CR1&=~(USART_CR1_M);//1 Start bit, 8 data bits
	USART2->CR1&=~(USART_CR1_PCE);// No parity bit
	USART2-> BRR= (4000000/115200);//baud div (clock/baudrade)

//	USART2-> CR1 = USART_CR1_UE;//usart enable
//	USART2-> CR1 = USART_CR1_TE;// transmiter enable
//	USART2-> CR1 = USART_CR1_RE; // reciver enable
	USART2-> CR1 |= USART_CR1_UE|USART_CR1_TE|USART_CR1_RE;

}
void UART2_SendStr(char *str){
	while(*str != '\0'){
		UART2_SendChar(*str);
		str++;
	}
}
void UART2_SendChar(char c){
	USART2->TDR = c;
	while(!(USART2->ISR & USART_ISR_TXE));
}



uint8_t UART2_RecChar(char *ch){
	if(USART2->ISR & USART_ISR_RXNE){	// Ctrl+@ send '\0' PuTTy
		*ch=USART2->RDR;
		rxbuffer[rxpos++]=USART2->RDR;
		if(USART2->RDR=='\0' || rxpos>19){
			for(int i=0;i<20;i++){
				tab1[i]=rxbuffer[i];//copy buffer
				rxbuffer[i]='\0';//clear buffer
				}
			rxpos=0;
			CompareReady=1;
		}
		return 0;
	}
	return 1;
}

uint32_t GetSystemTick(void){
	return Tick;
}
void SysTick_Handler(void){
	Tick++;
}
void Delay(uint32_t delay_ms){
	uint32_t StartTime=Tick;
	while(Tick<(StartTime+delay_ms));
}
