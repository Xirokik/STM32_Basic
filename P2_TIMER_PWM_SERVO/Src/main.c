/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/*
 * Servo SG90 0-180
 * 50Hz (20ms)  high state should be 1 ms for 0 degrees and 2 ms for 180 degrees
 * in practice,  high state is shorter for 0 degrees (0.6 ms) and longer for 180 degrees (2.3 ms)
 */

#include "main.h"

/*#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
*/
__IO uint32_t Tick;
uint8_t pos=40;

void ServoPin(void);
void TIM3Config(void);
void Delay(uint32_t delay_ms);
uint32_t GetSystemTick(void);

int main(void)
{
	SysTick_Config(4000000/1000);

	ServoPin();
	TIM3Config();

	/* Loop forever */
	while(1){
		for (pos = 30; pos <= 115; pos += 1) { // from 0 degrees to 180 degrees
			TIM3->CCR1=pos;              // set the servo to the "pos" position
		    Delay(25);
		  }
		  for (pos = 115; pos >= 30; pos -= 1) { //from 180 degrees to 0 degrees
			  TIM3->CCR1=pos;              // set the servo to the "pos" position
		    Delay(25);
		  }
	}
}
void ServoPin (){
	RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN;//enable gpioa

	GPIOA->MODER &= ~(GPIO_MODER_MODE6_0);// 10: Alternate function mode   (11 reset state)
	GPIOA-> AFR[0] |= GPIO_AFRL_AFSEL6_1; // 0010: AF2  alternate function low register (AFR- table 0-low register, 1- high register)
}


void TIM3Config(){
	//Timer config
	RCC-> APB1ENR1 |= RCC_APB1ENR1_TIM3EN; //power clock
	TIM3-> PSC= (80-1); //prescaler 4MHz /80 =50000 Hz, 0,02ms 1tick
	TIM3-> ARR= (1000-1);// auto-reload register  1000 * 0,02 ms = 20 ms per one timer cycle (50Hz)

	//PWM config
	//TIM3 -> CCMR1 &= ~(TIM_CCMR1_CC1S);//default as output
	TIM3-> CCMR1 |= TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_2;//pwm channel 0110: PWM mode 1, upcounting - active when TIMx_CNT<TIMx_CCR1
	TIM3->CCR1=74; //capture/compare register
	TIM3->CCER|= TIM_CCER_CC1E;//  Capture/Compare 1 output enable.
	//Enable interrupts
	TIM3->DIER|= TIM_DIER_UIE;//Update interrupt enable
	TIM3->DIER|=TIM_DIER_CC1IE;//Capture/Compare 1 interrupt enable

	NVIC_SetPriority(TIM3_IRQn,0);
	NVIC_EnableIRQ(TIM3_IRQn);

	TIM3->CNT=0; // clear counter
	TIM3-> CR1|=TIM_CR1_CEN;//enable counter(start)
}

void TIM3_IRQHandler(){
	if(TIM3->SR & TIM_SR_UIF){
		TIM3-> SR &= ~(TIM_SR_UIF); //cleared by 0
		//Update event-reload timer
	}

	if(TIM3->SR & TIM_SR_CC1IF){
			TIM3-> SR &= ~(TIM_SR_CC1IF); //cleared by 0
			//PWM capture/compare
		}


}

void SysTick_Handler(void){
	Tick++;
}

void Delay(uint32_t delay_ms){
	uint32_t StartTime=Tick;
	while(Tick<(StartTime+delay_ms)){

	}
}
uint32_t GetSystemTick(void){
	return Tick;
}
