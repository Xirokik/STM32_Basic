/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "main.h"
#include "gpio_conf.h"

/*#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
*/
__IO uint32_t Tick; //__IO volatile
uint32_t TimerLD2;

void ClockConfig(void);
void EXTI_Conf(void);

void Delay(uint32_t delay_ms);
uint32_t GetSystemTick(void);

int main(void)
{
	ClockConfig();
	SysTick_Config(16000000/1000);
	ConfigLD();
	ConfigLD2();
	ConfigButton();
	EXTI_Conf();
	TimerLD2=GetSystemTick();
	/* Loop forever */
	while(1){

		if(GetSystemTick()-TimerLD2>500){
			TimerLD2=GetSystemTick(); //Blink without delay
			GPIOA->ODR^=GPIO_ODR_OD7; //LD TOGGLE (XOR)
		}


	}
}
void ClockConfig(void){
	RCC->CR |= RCC_CR_MSION; // Active clock source
	while(!(RCC->CR&RCC_CR_MSIRDY)); //wait for clock source ready
	RCC->CR &= ~RCC_CR_MSIRANGE; //Clear range
	RCC->CR |= RCC_CR_MSIRANGE_8;// set range
	RCC->CR |= RCC_CR_MSIRGSEL;// enable to read from range
	RCC->CFGR &= ~RCC_CFGR_SW; // clear clock source
	RCC->CFGR |= RCC_CFGR_SW_MSI;// set clock source
	while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI);//wait until MSI is set as clock source


}
void EXTI_Conf(void){

	RCC->APB2ENR|= RCC_APB2ENR_SYSCFGEN; //SYSCFG + COMP + VREFBUF clock enable

	SYSCFG->EXTICR[1]|=SYSCFG_EXTICR2_EXTI6_PA; // SYSCFG external interrupt configuration register

	EXTI->IMR1|=EXTI_IMR1_IM6;//Interrupt request from Line 6 is not masked

	EXTI->FTSR1|=EXTI_FTSR1_FT6; //Falling trigger enabled (for Event and Interrupt) for input line

	NVIC_SetPriority(EXTI9_5_IRQn,0);
	NVIC_EnableIRQ(EXTI9_5_IRQn);


}
void EXTI9_5_IRQHandler (void){
	if(EXTI->PR1&EXTI_PR1_PIF6){
		EXTI->PR1|=EXTI_PR1_PIF6; //Selected trigger request occurred , cleared by writing a ‘1’
		GPIOA->ODR^=GPIO_ODR_OD5;
	}
}

void SysTick_Handler(void){
	Tick++;
}

void Delay(uint32_t delay_ms){
	uint32_t StartTime=Tick;
	while(Tick<(StartTime+delay_ms));
}
uint32_t GetSystemTick(void){
	return Tick;
}
